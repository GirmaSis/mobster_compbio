`c`
c
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
X = x
X
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
source('~/Documents/GitHub/dbpmm/R/util.R')
source('~/Documents/GitHub/dbpmm/R/class.methods.R')
source('~/Documents/GitHub/dbpmm/R/plots.R')
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
source('~/Documents/GitHub/dbpmm/R/density.R')
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
dbpmm.fit.params = list(
K = 1:5,
samples = 10,
init = 'peaks',
tail = TRUE,
epsilon = 1e-10,
maxIter = 6000,
is_verbose = FALSE,
fit.type = 'MM',
parallel = TRUE,
cores.ratio = .8,
file.dump = NA,
seed = 12345,
top = 10,
annotation = NULL
)
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
dbpmm.fit.params = list(
K = 1:5,
samples = 10,
init = 'peaks',
tail = TRUE,
epsilon = 1e-10,
maxIter = 6000,
is_verbose = FALSE,
fit.type = 'MM',
parallel = F,
cores.ratio = .8,
file.dump = NA,
seed = 12345,
top = 10,
annotation = NULL
)
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
dbpmm.fit.params = list(
K = 1,
samples = 1,
init = 'peaks',
tail = TRUE,
epsilon = 1e-10,
maxIter = 6000,
is_verbose = FALSE,
fit.type = 'MM',
parallel = F,
cores.ratio = .8,
file.dump = NA,
seed = 12345,
top = 10,
annotation = NULL
)
tail.fit = dbpmm.fit(
X = X,
K = dbpmm.fit.params$K,
samples = dbpmm.fit.params$samples,
init = dbpmm.fit.params$init,
tail = dbpmm.fit.params$tail,
epsilon = dbpmm.fit.params$epsilon,
maxIter = dbpmm.fit.params$maxIter,
is_verbose = dbpmm.fit.params$is_verbose,
fit.type = dbpmm.fit.params$fit.type,
parallel = dbpmm.fit.params$parallel,
cores.ratio = dbpmm.fit.params$cores.ratio,
file.dump = dbpmm.fit.params$file.dump,
seed = dbpmm.fit.params$seed,
top = dbpmm.fit.params$top,
annotation = dbpmm.fit.params$annotation
)
# Best fit
best.fit = tail.fit[[1]]
best.fit
plot(ddbpmm)
plot(best.fit)
require(ggplot2)
plot(best.fit)
# remove tail mutations for the best fit, if the tail is used
if(all(is.na(best.fit$tail)))
{
cat(red('\n\n ===== Best dbpmm fit does not have a tail ===== \n\n'))
}
curX = length(X)
X = X[best.fit$labels != 'Tail']
save(X, file = paste(dbpmm.fit.params$file.dump, '-noTail.RData', sep = ''))
cat(green('\n\n ===== Best dbpmm fit with tail, removed',
(curX-length(X)),
'observations; reduction to',
round(length(X)/curX, 2),
'% ===== \n\n'))
cat(green('\n\n ===== Best dbpmm fit with tail, removed',
(curX-length(X)),
'observations; reduction to',
round(length(X)/curX, 2) * 100,
'% ===== \n\n'))
fit.vbdbmm = vbdbmm::vb_bmm1D_fit(
X = X,
K = vbdbmm.fit.params$K,
alpha_0 = vbdbmm.fit.params$alpha_0,
a_0 = vbdbmm.fit.params$a_0,
b_0 = vbdbmm.fit.params$b_0,
max_iter = vbdbmm.fit.params$max_iter,
epsilon_conv = vbdbmm.fit.params$epsilon_conv,
restarts = vbdbmm.fit.params$restarts,
parallel = vbdbmm.fit.params$parallel,
silent = vbdbmm.fit.params$silent
)
X
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
devtools::document()
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
devtools::document()
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/util.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/util.R')
source('~/Documents/GitHub/dbpmm/R/util.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/util.R')
source('~/Documents/GitHub/dbpmm/R/util.R')
source('~/Documents/GitHub/dbpmm/R/util.R')
source('~/Documents/GitHub/dbpmm/R/util.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
cat(bgBlue(
red('\n\n ===== Tail-detection via Dirichlet Beta-Pareto Mixtures ===== \n\n')))
cat(bgBlue(
white('\n\n ===== Tail-detection via Dirichlet Beta-Pareto Mixtures ===== \n\n')))
cat(bgBlue(white('\n\n ===== Tail-detection via Dirichlet Beta-Pareto Mixtures ===== \n\n')))
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
tail.fit
# Best fit
best.fit = tail.fit[[1]]
best.fit
best.fit$tail
best.fit
best.fit[[1]]
best.fit[1]
best.fit
x = best.fit
x
x$labels
table(x$labels)
best
x
unlist(clus.size)
clus.size = table(x$labels)
unlist(clus.size)
names(clus.size)
clus.size[1]
clus.size[order(clus.size)]
clus.size[order(clus.size)]
x
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
x
x$beta
best.fit$beta[c('a', 'b', 'mean'), ]
best.fit$beta[c('a', 'b', 'mean'), , drop = FALSE]
fits.tail.table = best.fit$beta[c('a', 'b', 'mean'), , drop = FALSE]
print(paste('TAIL: ', all(is.null(best.fit$tail))))
best.fit$tail
as.data.frame(fits.tail.table)
as.data.frame(best$tail)
as.data.frame(best.fit$tail)
data.frame(best.fit$tail)
data.frame(best.fit$tail, row.names = 'TAIL')
print(data.frame(best.fit$tail, row.names = 'TAIL'))
print(fits.tail.table)
print(fits.table)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
rownames(fits.table) = second.fit
fits.table = Reduce(rbind, fits.table)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
fits.table
# else cat(paste(x$N.k, collapse = ', '), "\n")
print(clus.size)
paste(names(clus.size), clus.size)
paste(names(clus.size), clus.size, sep = '=')
paste(names(clus.size), clus.size, sep = ' = ', collapse = ', ')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
print(data.frame(best.fit$tail, row.names = 'TAIL'))
print(data.frame(NULL, row.names = 'TAIL'))
!all(is.null(best.fit$tail))
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
devtools::document()
sessionInfo()
devtools::document()
DPpackage::DPbetabinom
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
devtools::document()
devtools::document()
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
??mle
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
X= runif(100)
k=3
fit = NULL
fit$z_nk = matrix(runif(10000), ncol = 3)
fit$p
fit$pi = runif(3)
fit
fit$a=runif(3)
fit$b=runif(3)
MLE.fit = stats4::mle(
minuslogl = .NLLBetaMix(k, X, fit$z_nk, fit$pi),
start = list(a = fit$a[k-1], b = fit$b[k-1]))
MLE.fit = stats4::mle(
minuslogl = dbpmm:::.NLLBetaMix(k, X, fit$z_nk, fit$pi),
start = list(a = fit$a[k-1], b = fit$b[k-1]))
MLE.fit = stats4::mle(
minuslogl = function(a, b){return(-3)},
start = list(a = fit$a[k-1], b = fit$b[k-1]))
MLE.fit = stats4::mle(
minuslogl = function(a, b){return(a + b)},
start = list(a = fit$a[k-1], b = fit$b[k-1]))
MLE.fit
coef(MLE.fit)
coeff(MLE.fit)
Coeff(MLE.fit)
MLE.fit
names(MLE.fit)
class(MLE.fit)
stats4::coef(MLE.fit)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
source('~/Documents/GitHub/dbpmm/R/ML_fit_1D.R')
library(dbpmm)
load("~/Documents/GitHub/test.dbpmm/Synthetic Tests/[dbpmm] Popgen_batch_1.1/results/0018092974cdb66a9258b87d7f43ac30f5051782-allRuns.RData")
fits = res$runs
res$best
fits
.getGGplotHistogram = function(x, annotation = NULL, palette = 'Spectral',
tail.color = c('gainsboro', 'darkgray'),
alpha = .5, max.height.hist = TRUE, cex = 1,
bg.color = 'ivory2', main = 'MOBSTER fit', ...)
{
domain = seq(0, 1, 0.01)
labels = names(x$pi)
labels.betas = colnames(x$beta)
pi = x$pi
ICL = round(as.numeric(x$scores$ICL), 2)
NLL = round(as.numeric(x$scores$NLL), 2)
K = as.numeric(x$K)
col = RColorBrewer::brewer.pal(
RColorBrewer::brewer.pal.info[palette, 'maxcolors'], palette)
col = colorRampPalette(col)(x$Kbeta)
col.histogram = c(tail.color[1], col)
col.lines = c(tail.color[2], col)
names(col.histogram) = names(col.lines) = labels
# Plot 1 -- main histogram
df = data.frame(X = x$X, Cluster = x$labels, Color = col[x$labels])
vvv = lapply(1:x$K,
function(w)
data.frame(X = domain,
Cluster = labels[w],
y = ddbpmm(x, data = domain, components = w, log = FALSE)))
names(vvv) = labels
# Histogram coloured according to clustering assignments
tit = bquote(bold(.(main)))
extented.labels = levels(df$Cluster)
if(!all(is.na(x$tail))) extented.labels['Tail'] = paste('Tail : ', round(x$shape, 2), '; x >', round(x$scale, 2), sep ='')
else extented.labels['Tail'] = bquote('Tail: OFF')
betavals = x$beta[c('mean', 'var'), , drop = FALSE]
betavals['mean', ] = round(betavals['mean', ], 3)
betavals['var', ]  = format(betavals['var', ] , scientific = T, digits = 3)
for(clus in paste('C', 1:x$Kbeta, sep = ''))
extented.labels[clus] = paste(clus, ' : ', betavals['mean', clus], ' (', betavals['var', clus], ')', sep = '')
p = ggplot(df, aes(X, fill = Cluster, y = ..count../sum(..count..))) +
geom_histogram(alpha = alpha, position = 'identity', binwidth = 0.01) +
scale_fill_manual(values = col.histogram, labels = extented.labels) +
labs(
title = tit,
subtitle = annotation,
x = "Observed Frequency", y = "") +
theme_classic(base_size = 10 * cex)
if(max.height.hist) {
yMax = max(ggplot_build(p)$data[[1]]$y)
p = p + ylim(0, yMax)
}
df.m = data.frame(variable = labels.betas, Mean = x$beta['mean', labels.betas])
rownames(df.m) = df.m$variable
# Add densities to the plot
vvv = lapply(vvv, function(w) {w$y = w$y * 0.01; w}) # Scale density wrt binwidth
for(i in seq(labels)) p = p + geom_line(data = vvv[[i]], aes(y = y, x = X), colour = col.lines[i])
# Add means for Beta components
for(i in labels.betas) p = p +  geom_vline(data = df.m[i ,], aes(xintercept = Mean), colour = col.lines[i], linetype = "longdash")
# Annotate convergency value
if(x$status) p = p + annotate("text", x = .9, y = yMax , label = paste(x$fit.type, ': CONVERGED'), size = 3, colour = 'darkgreen')
else   p = p + annotate("text", x = .9, y = yMax, label = paste(x$fit.type, ': NOT CONVERGED'), size = 3, colour = 'red')
p
}
.getGGplotHistogram(fits[[1]])
library(dbpmm)
library(dbpmm)
library(dbpmm)
library(dbpmm)
library(dbpmm)
library(dbpmm)
library(dbpmm)
library(dbpmm)
library(dbpmm)
library(dbpmm)
