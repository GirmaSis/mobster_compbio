# Gaussian KDE of posterior density for univariate Dirichlet MM with Binomial likelihood.
# gibbs -- structure returned by Andreas' Gibbs sample 
# kde.density.smooth -- density smoothing (suggested <1)
# is.norm -- if the mixing proportions of the mixtures are normalized or not
# scale.all -- scale the histogram of the empirical posterior, and the density in [0,1]
#plot.samples -- draw also 20 random samples from the posterior
kdeposterior =  function(gibbs,  kde.density.smooth = 0.05, breaks = 20, is.norm = TRUE, scale.all = TRUE, plot.box = FALSE, plot.samples = FALSE, collapse.plots = FALSE)
{	
	N = gibbs$dat$N.Sims - gibbs$dat$burnin # num of MCMC samples
	n = 512 # num of x-points to approximate the posterior
	
	pi = gibbs$draws$pi #(mixing proportions, usually written as \pi_j)
	p = gibbs$draws$p 	# (parameter of the mixture)

	
	X = gibbs$dat$X
	r = gibbs$dat$r
	
	if(! is.norm)  pi = t(apply(pi, 1, function(x) x/sum(x)))
	
	posterior.samples = matrix(NA, ncol = N, nrow = n)
	
	# Generate the posterior density for p, weighted by pi
	# xx is the location of density estimates generated by R's density function, 0 < xx < 1
	# posterior.samples are the draws of density estimates from the posterior distribution of  
	xx = density(
		p[1, ],
		weights = pi[1,], 
		adjust = kde.density.smooth, 
		from=0, 
		to=1)$x
		
	for (i in 1:N) 
	{
		posterior.samples[,i] <- density(
			p[i, ], 
			weights = pi[i, ], 
			adjust= kde.density.smooth, 
			from=0,
			to=1)$y
	}
	
	# # Generate the figure for the posterior distribution of the clusters
	numplots = 1
	if(plot.samples) numplots = numplots + 1
	if(plot.box) numplots = numplots + 1
	if(collapse.plots) par(mfrow=c(numplots,1))
	
	# # Plot raw data
	vaf_hist = hist(X/r, 
		# breaks=seq(0, 1.1, 0.01),
		breaks = breaks,
		plot = FALSE)
			
	## We rescale in [0,1] the histogram and the density if scale.all = TRUE
	ymax = max(vaf_hist $density)
	if(scale.all) {
		message('[scale.all = TRUE] Histogram and density plot rescaled to the same unit')
		vaf_hist$density = vaf_hist$counts/max(vaf_hist $counts)	
		posterior.samples = posterior.samples/max(posterior.samples)
		ymax = 1
	}
	
	plot(vaf_hist,		
		col="lightgrey",
		freq=FALSE, 
		xlab="Fraction", 
		ylab= ifelse(scale.all, "Density (scaled)", "Density"),
		axes = !scale.all,
		ylim=c(0,ymax), 
		xlim=c(0,1), 
		main="Posterior distribution via KDE"
		)	
	
	axis(side=1, at=seq(0,1,0.1), 
		labels=seq(0,1,0.1))
	
	# # Plot 95% posterior intervals for the density
	polygon(
		c(xx, rev(xx)), 
		c(
			apply(posterior.samples, MARGIN=1, FUN=quantile, probs=0.975), 
			rev(apply(posterior.samples, MARGIN=1, FUN=quantile, probs=0.025))), 
		border="plum4", 
		col=cm.colors(1,alpha=0.3))

	# # Plot estimated density
	lines(xx, apply(posterior.samples, MARGIN=1, FUN=quantile, probs=0.5), col="plum4", lwd=3)
	
	## Plot samples if required
	if(plot.samples)
	{
		message('[plot.samples = TRUE] Drawing also 20 random posterior samples')
		
		require(RColorBrewer)
		colors = colorRampPalette(brewer.pal(9, 'Set1'))(20)

		plot(posterior.samples[, 1], 
			type = 'l', 
			main = '20 random posterior samples', 
			ylab = ifelse(scale.all, "Density (scaled)", "Density"), 
			xlab="Fraction",
			ylim = c(0,ymax),
			xaxt = 'n') 
			
		# axis(side=1, at=seq(0,1,0.1), 
			# labels=seq(0,1,0.1))

		w = sample(1:ncol(posterior.samples), 20)
		
		for (i in 1:length(w))
			lines(posterior.samples[, w[i]], col = colors[i]) 
	}
	
	# ######################
	# # Generate the figure showing the order statistics for the weight attributed to each of the clusters
  if(plot.box)
  {
    message('[plot.box = TRUE] Showing also pi\'s order statistics')
    
		sorted.kappa <- t(apply(pi, MARGIN=1, FUN=sort, decreasing=TRUE))
	  head(sorted.kappa)

	  kappa.df <- data.frame(kappa = c(sorted.kappa), order = rep(1:gibbs$dat$K, each=dim(sorted.kappa)[1]))
	  head(kappa.df)

	  boxplot(kappa ~ order, data=kappa.df, col="plum4", xlab="Cluster", ylab="Proportion of observations", main="Order statistics for fraction of observations assigned to each cluster")
  }
}	
