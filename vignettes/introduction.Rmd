---
title: "A.Basic mobster usage"
author: "Giulio Caravagna"
date: "September 2019"
institute: "Institute for Cancer Research"
email: "giulio.caravagna@icr.ac.uk"
output: rmarkdown::github_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette describes the basic usage of the open source MOBSTER R package for subclonal deconvolution in cancer. 

The MOBSTER package is available at [Github](https://github.com/caravagn/MOBSTER). 

```{r, message=FALSE, warning=F}
library(mobster)
```

## Generating a MOBSTER dataset

The input data must be formatted as an object of class `data.frame` (or, `tibble`) with at least one columun named `VAF` whose values are numerical, and no `NA` values are present. If a dataset has at least this column, then it can be processed with MOBSTER; the output object will contain a copy of the input data. 

> Data released with the package is accessible as usual via `data("xxx", package = 'mobster')` where `xxx` is the name of the dataset to load. See the package manual for a list of available data.

In this vignette we sample a random dataset using the `random_dataset` function, which has different parameters to customize the data creation. Shortly, you can set 

* the number of samples (`n`, mutations) and Beta components (`k`, subclones) to generate;
* ranges and constraints on the size of the components;
* ranges for the mean and variance of the Beta components.

In this example we fix the seed and the parameter `B = Beta_variance_scaling`, which  affects the variance of the Beta(s). Because the variance is sampled as `u/B ~ U[0,1]` (scaled by this value), values on the order of `1000` give low variance, representative of high-coverage sequencing, while `100` represents a dataset with quite some dispersion. This is because the underlyin allele-frequency data is generated from a putative Beta-Binomial generative model.

```{r, message=FALSE, warning=F}
dataset = random_dataset(
  seed = 123, 
  Beta_variance_scaling = 100    # variance ~ U[0, 1]/Beta_variance_scaling
  )
```

A list with 3 components is returned, which you can access to see the actual data, the sampled parameters of the generative model, and a plot of the data. 

> MOBSTER's statistical model, a Dirichlet Beta Pareto Mixture Model (DBPMM), provides an implementation for its density function (`ddbpmm`), and a sampler (`rdbpmm`) which is used internally by `random_dataset`.


```{r, fig.width=4, fig.height=3}
# Data, in the MOBSTER input format with a "VAF" column.
print(dataset$data)

# The generated model contains the parameters of the Beta components (a and b),
# the shape and scale of the tail, and the mixing proportion. 
print(dataset$model)

# A plot object (ggplot) is available where each data-point is coloured by 
# its generative mixture component. The vertical lines annontate the means of
# the sampled Beta distributions.
print(dataset$plot)
```

## Fitting a dataset<a name="fitting"></a>

Function `mobster_fit` is the main function to fit a MOBSTER model. 

This function implements a model selection routine that, by default, scores the models with the *reduced Incomplete Classification Likelihood* (reICL). reICL is a variant to the popular BIC score which uses the entropy of the latent variables of the model; the reICL formulation uses a particular version of this score, as discussed in the main MOBSTER paper. 

>MOBSTER uses the [easypar](https://github.com/caravagn/easypar) package to implement parallel computations easily.

This function has several parameters that allow one customizing the type of fit, the optimization task etc. Here we sample 1 fit per configuration of parameters, and set the optimization to stop when the variation between the mixing proportions and the likelihood is below `epsilon = 1e-4` (usually, one would use `epsilon = 1e-10` but with this value the compilation of this vignette is faster).

```{r, fig.width=4, fig.height=3}
# Fit by MOBSTER (default K = 1, ..., 3, and tail TRUE/ FALSE)
fit = mobster_fit(
  dataset$data,    
  samples = 1,      # Number of runs per parameters configuration
  epsilon = 1e-4,   # Optimisation (delta across rus to determine stop)
  parallel = TRUE   # Parallel (multi-core) run
  )
```

As a result, a call of `mobster_fit` will return a list with:

* the best fit, accessible as named object `fit$best`;
* a `fit$runs` list that contains the top fits (ranked by score), the object available as `best` will match the head of this list, `fit$runs`;
* and a `fit$fits.table` that summarises the scores for each one of the runs.

The `fits.table` reports also other scores for the model fits, which include AIC, BIC, ICL the entropy and the likelihood of the model. Each fit object (`best` or any object stored in `runs`) is from class `dbpmm`. This class provides S3 objects for print and plot of a MOBSTER model
```{r, fig.width=4, fig.height=3}
# Print the best model, as well as the first 3 models in the runs list
print(fit$best)

print(fit$runs[[1]]) # same as best
print(fit$runs[[2]])
print(fit$runs[[3]])
```

The simplest visualization for MOBSTER's fits is a coloured histogram, where colours represent clustering assignments, overlaid to the model density. By default MOBSTER names Beta clusters according to the decreasing order of their mean; so `C1` is always the label of the cluster with highest mean, etc. The basic plot shows, mirrored on the y-axis, the percentage of sum-of-squared-error (SSE) as a function of the input VAF (which is termed `Observed Frequency` in the x-axis). The plot caption annotates some information about the fitting.

```{r, fig.width=5, fig.height=4}
# Plot the best model
plot(fit$best)
```

A comparative plot between the fit and the simulated data can be assembled with `ggpubr` function, which can take two `ggplot` objects and assemble them, or with  `plot_grid` from the `cowplot` package (which provides better figure alignments).
```{r, fig.width=10, fig.height=4}
figure = cowplot::plot_grid(
  dataset$plot, 
  plot(fit$best), 
  ncol = 2,
  align = 'h')

print(figure)
```

Hard clustering assignments are computed and can be accessed with function `Clusters`, the function also allows imposing a minimum cutoff to the reponsibilities of the mutations (if a mutation's maximum responsibility is below the cutoff, its assignment will be `NA`). Note that the return tibble is a copy of the input, with the new  `cluster` column, plus a set of columns for the latent variables in MOBSTER (the clustering reponsibilities).
```{r}
# Assign mutations with at least 80% of probability mass to their maximum responsibility
clusters = Clusters(
  fit$best, 
  cutoff_assignment = .8
  )

print(clusters)
```
