---
title: "Vignette for mobster"
author: "Giulio Caravagna"
date: "September 2019"
institute: "Institute for Cancer Research"
email: "giulio.caravagna@icr.ac.uk"
output:
  html_document:
    theme: cosmo
    highlight: tango
    output:
vignette: >
  %\VignetteEngine{knitr::knitr}
  %\VignetteIndexEntry{Vignette for mobster}
  %\usepackage[UTF-8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=F}
require(mobster)
```

This vignette describes the basic usage of the MOBSTER R package for sunclonal deconvolution in cancer. The package is available at [Github](https://github.com/caravagn/MOBSTER). 


## Generating and analysing a random MOBSTER dataset

The input data must be formatted as a data.frame/ tibble with at lease one columun named `VAF`. Example datasets and fits are released as `data` inside the package. In this vignette we sample a random dataset using the `random_dataset` function, which has different parameters to customize the data creation. 

You can set 

* the number of samples (mutations) and Beta components (subclones) to generate;
* constraint on the size of the components, the position and spread of the Beta means, and the variance of the Beta components.
* set the seed to fix the process.

In this example we fix the seed and the parameter `Beta_variance_scaling`, which  affects the variance of the Beta(s). Because that is generated as `U[0,1]` and scaled by this value, values on the order of 1000 give low variance, 100 represents a dataset with quite some dispersion (compared to a putative Binomial generative model).

```{r, message=FALSE, warning=F}
dataset = random_dataset(seed = 123, Beta_variance_scaling = 100)
```

A list with 3 components is returned, which you can access to see the actual data, the sampled parameters of the generative model, and a plot of the data. Notice that this function is a wrapper to the actual `rdbpmm` function, the implementation of the sampler from the density function of the Dirchlet Beta Pareto Mixture Model object that is implemented in MOBSTER -- see `?rdbpmm` and `?ddbpmm`.
```{r, fig.width=4, fig.height=3}
# Data, in the MOBSTER input format with a "VAF" column.
print(dataset$data)

# The generated model contains the parameters of the Beta components (a and b), the shape and scale of the tail, and the mixing proportion. 
print(dataset$model)

# A plot object (ggplot) is available where each data-point is coloured by its generative mixture component. The vertical lines annontate the means of the sampled Beta distributions.
print(dataset$plot)
```

Compute the fit, then plot the best fit which is returned into a named list under the name `best`. The fit is computed exploiting the [easypar](https://github.com/caravagn/easypar) package in order to run in parallel the computations.
```{r, fig.width=4, fig.height=3}
# Fit by MOBSTER
fit = mobster_fit(dataset$data, samples = 1, epsilon = 1e-4, parallel = TRUE)

# Plot the best model
plot(fit$best)
```

A comparative plot can be assembled with `ggpubr` function `ggarrange(dataset$plot, plot(fit$best), ncol = 2)`. The fit is an object of class `dbpmm`, which has an S3 method to print to screen
```{r}
print(fit$best)
```
Hard clustering assignments are computed and can be accessed with function `Clusters`, the function also allows imposing a minimum cutoff to the reponsibilities of the mutations (if a mutation's maximum responsibility is below the cutoff, its assignment will be `NA`). Note that the return tibble is a copy of the input, with the new  `cluster` column, plus a set of columns for the latent variables in MOBSTER (the clustering reponsibilities).
```{r}
# Assign mutations with at least 80% of probability mass to their maximum responsibility
clusters = Clusters(fit$best, cutoff_assignment = .8)
print(clusters)
```

A set of plots is available to inspect further details of a fit. For example,
* the latent variables can also be visualized as heatmap;
* the mixing proportions as barplot;
* the trace of the negative log-likelihood can be inspected;
* and the initial condition of the fit can be plot as density.
```{r, fig.width=4, fig.height=5}
# Assign mutations with at least 80% of probability mass to their maximum responsibility
plot_latent_variables(fit$best, cutoff_assignment = .8)
```

```{r, fig.width=4, fig.height=3}
# Mixing proportions
plot_mixing_proportions(fit$best)

# MNLL trace
plot_NLL(fit$best)

# Plot the initial condition of the fit
plot_init(fit$best)
```


## Selecting alternative best models

The function `mobster_fit` returns a list of 3 components: the best fit (named `best`), a `runs` list of top fits ranked by score, and a `fits.table` that summarises the scores for each one of the runs.

```{r, fig.width=5, fig.height=4}
# The second top run is avaiable as well
print(fit$runs[[2]])

# A general table for all scores is also available
print(fit$fits.table)
```


A set of plots is available to inspect model selection for a fit. A plot of the sum of squared error (SSE) between the fit density and the data (binned with bins of size 0.01) is available.

```{r, fig.width=3, fig.height=6}
# Goodness of fit (SSE)
plot_gofit(fit)
```

A plot of all the computed scoring functions (BIC, AIC, ICL and reICL) is shown, which helps understanding if the best model with the default score (reICL) is the best also according to the other scores (the red dot represents the best model according to each score).
```{r, fig.width=4, fig.height=3}
plot_fit_scores(fit)
```


These functions can be all wrapped by a call to `plot_model_selection` which plots the above summary statistics and the fits for each one of a set of top models (change the parameter `TOP` to select how many plots should be computed).
```{r, fig.width=9, fig.height=9, message=FALSE, warning=FALSE}
plot_model_selection(fit, TOP = 5)
```
