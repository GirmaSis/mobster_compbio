---
title: "Confidence estimation via the bootstrap"
author: "Giulio Caravagna"
date: "September 2019"
institute: "Institute for Cancer Research"
email: "giulio.caravagna@icr.ac.uk"
output: rmarkdown::github_document
vignette: >
  %\VignetteIndexEntry{Confidence estimation via the bootstrap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vignette describes how to compute the *bootstrap* confidence of a MOBSTER model.

The MOBSTER R package is available at [Github](https://github.com/caravagn/MOBSTER). 


```{r, message=FALSE, warning=F}
library(mobster)
```

## Bootstrapping a model

There are two types of bootstrap functions available in MOBSTER: *parametric* and *nonparametric*.

* The former samples data from the model, and re-runs the fits;
* the latter re-samples the data (with repetitions), and re-runs the fits. 

In both cases a distribution of the parameter fits can be approximated, and in the case of nonparametric bootstrap also the probability of clustering together two mutations can be computed.

To speed up the computation we show this with a smaller dataset.
```{r eval=T, fig.height=4, fig.width=8, message=FALSE, warning=FALSE}
# Data generation
dataset = random_dataset(
  N = 400, 
  seed = 123, 
  Beta_variance_scaling = 100
  )

# Fit model
fit = mobster_fit(dataset$data, samples = 1)

# Composition with cowplot
figure = cowplot::plot_grid(
  dataset$plot, 
  plot(fit$best), 
  ncol = 2, 
  align = 'h')

print(figure)
```

Now we are ready to compute `n.resamples` nonparametric bootstraps, and the bootstrapped statistics. We can do that using function `mobster_bootstrap` to which we can pass some parameters that will be forwarded to the calls of `mobster_fit`

```{r, fig.width=9, fig.height=9, message=FALSE, warning=FALSE, eval=T}
# The returned object contains also the list of bootstrap resamples, and the fits.
bootstrap_results = mobster_bootstrap(
  fit$best,
  bootstrap = 'nonparametric',
  n.resamples = 3,
  epsilon = 1e-4,   # forwarded to mobster_fit, optimization epsilon
  K = c(1, 2),      # forwarded to mobster_fit, test only models with 1 or 2 Betas
  cache = NULL      # forwarded to mobster_fit, no cache
  )
```
The output object contains all the relevant information to analyze the results of this computation, which include the bootstrap resamples, the fits and possible errors.

```{r}
# Resamples are available for inspection as list of lists, 
# with a mapping to record the mutation id of the resample data.
# Ids are row numbers.
print(bootstrap_results$resamples[[1]][[1]] %>% as_tibble())

# Fits are available inside the $fits list
print(bootstrap_results$fits[[1]])
plot(bootstrap_results$fits[[1]])

# If any the computations raised an erorr, they will be stored 
# inside %errors rather than $fits
print(bootstrap_results$errors)
```

## Bootstrap statistics

Bootstrap statistics can be computed with MOBSTER function `bootstrapped_statistics`. 

The time to compute these stats depends on the number of mutations in the data, and the number of bootstrap resamples. In case of a `nonparmaetric` bootstrap `bootstrapped_statistics` computes also the data co-clustering probability, defined as the probability of any pair of mutations in the data to be clustered together across resamples. This statistics is the one that takes most time, as it its complexity scales as `N * N * B` with `N` mutations and `B` bootstrap resamples.

> Note that this probability depends on the joint resample probability of each pair of mutations, which is computable because samples are independent and uniform, and therefore each mutation is bootstrapped with probability 1/N.

```{r, fig.width=2, fig.height=3}
# This function plots also to screen a bunch of statistics that are also returned
bootstrap_statistics = bootstrapped_statistics(
  fit$best, 
  bootstrap_results = bootstrap_results
  )
```

Object `bootstrap_statistics` contains several tibbles that aggregate the data, and for each one of them there is a MOBSTER function to plot the data.
```{r, fig.width=2, fig.height=3}
# All bootstrapped values
print(bootstrap_statistics$bootstrap_values)

# The model probability
print(bootstrap_statistics$bootstrap_model)

# The parameter stastics
print(bootstrap_statistics$bootstrap_statistics)
```


Bootstrapping, one can plot the model probability across re-samples as a barplot 
```{r, fig.width=2.5, fig.height=3}
plot_bootstrap_model_frequency(
  bootstrap_results, 
  bootstrap_statistics
  )
```

Similarly, one can compute the parameter probabilities across re-samples, which we here aggregate as a figure.
```{r, fig.width=12, fig.height=3}
# Plot the mixing proportions
mplot = plot_bootstrap_mixing_proportions(
  fit$best, 
  bootstrap_results = bootstrap_results, 
  bootstrap_statistics = bootstrap_statistics
  )

# Plot the tail parameters
tplot = plot_bootstrap_tail(
  fit$best, 
  bootstrap_results = bootstrap_results, 
  bootstrap_statistics = bootstrap_statistics
  )

# Plot the Beta parameters
bplot = plot_bootstrap_Beta(
  fit$best, 
  bootstrap_results = bootstrap_results, 
  bootstrap_statistics = bootstrap_statistics
  )

# Figure
figure = ggarrange(
  mplot,
  tplot,
  bplot,
  ncol = 3, nrow = 1,
  widths = c(.7, 1, 1)
)

print(figure)
```

Bcause this is a nonparametric bootstrap run, the co-clustering probability can be plot as well
```{r, fig.width=5.6, fig.height=5}

plot_bootstrap_coclustering(
  fit$best, 
  bootstrap_results = bootstrap_results, 
  bootstrap_statistics = bootstrap_statistics
  )
```